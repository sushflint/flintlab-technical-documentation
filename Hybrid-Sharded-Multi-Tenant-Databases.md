# Hybrid-Sharded Multi-Tenant Database Design for Flintlab Mobile Testing Platform

## Table of Contents
1. [Introduction to Hybrid-Sharded Multi-Tenant Databases](#introduction)
2. [Why It's Right for Our Use Case](#use-case)
3. [Schema Design](#schema-design)
4. [Setting Up MongoDB and PostgreSQL with Citus](#setup)
5. [Developing Microservices on the Hybrid Architecture](#microservices)

## 1. Introduction to Hybrid-Sharded Multi-Tenant Databases <a name="introduction"></a>

### What is Multi-Tenancy?
Multi-tenancy refers to a software architecture where a single instance of a software application serves multiple customers, known as tenants. In a multi-tenant database, data for all tenants is stored in a shared database, but each tenant's data is isolated and invisible to others.

### What is Sharding?
Sharding is a database partitioning technique that divides large databases into smaller, faster, and more manageable parts called shards. Each shard holds a subset of the total data, and collectively, the shards make up the entire database.

### What is Hybrid Sharding?
Hybrid sharding combines both horizontal sharding and vertical partitioning. It allows for distributing data across multiple databases and servers, providing flexibility and scalability. In a hybrid-sharded multi-tenant database:

- Shared Database Cluster: Multiple tenants share the same database shards.
- Exclusive Database Cluster: High-tier tenants have dedicated databases.

### Benefits
- Scalability: Efficiently handle growing amounts of data and traffic.
- Flexibility: Accommodate different tenant requirements.
- Isolation: Provide data isolation for compliance and security.
- Cost-Effectiveness: Optimize resource utilization.

## 2. Why It's Right for Our Use Case <a name="use-case"></a>

Our mobile testing platform serves a diverse range of tenants, from trial users to premium subscribers. Each group has varying requirements:

- Trial and Basic Users: Require standard features with less resource consumption.
- Premium Users: Need advanced features, dedicated resources, and compliance assurances.

### Alignment with Our Needs
- Scalability: Handle large volumes of test data generated by multiple tenants.
- Performance: Ensure fast read/write operations for real-time testing.
- Flexibility: Support structured and semi-structured data (test logs, device info).
- Isolation: Provide dedicated resources for premium tenants.
- Cost Efficiency: Optimize infrastructure costs by sharing resources where appropriate.

By implementing a hybrid-sharded multi-tenant database, we can:

- Provide High Performance: Use MongoDB's sharding for shared clusters to distribute load.
- Ensure Consistency: Use PostgreSQL with Citus for strong consistency in exclusive clusters.
- Offer Customization: Tailor resources to tenant needs, enhancing customer satisfaction.

## 3. Schema Design <a name="schema-design"></a>

### Overview
Our architecture leverages both MongoDB and PostgreSQL to meet different requirements:

- MongoDB: For the Shared Database Cluster.
- PostgreSQL with Citus: For the Exclusive Database Cluster.
- PostgreSQL: For the Global User Table and User Management Service.

### Global User Management
Database: PostgreSQL

Tables:
- users: Stores basic user information for authentication.
  - user_id
  - email
  - hashed_password
  - created_at
  - last_login
- user_tenants: Associates users with tenants.
  - user_id
  - tenant_id
  - role
  - permissions

### Shared Database Cluster (MongoDB)
Database: MongoDB (Sharded)

Collections:
- tenant_{tenant_id}_test_results: Stores test results for each tenant.
- tenant_{tenant_id}_logs: Stores logs and semi-structured data.

Sharding Key: tenant_id

### Exclusive Database Cluster (PostgreSQL with Citus)
Database: PostgreSQL with Citus extension

Tables:
- test_results: Partitioned per tenant for scalability.
  - test_id
  - tenant_id
  - device_info
  - results
  - timestamp
- logs: Stores detailed logs.
  - log_id
  - tenant_id
  - log_data
  - timestamp

Distribution Column: tenant_id

### Data Flow Diagram
```bash
graph TD
    A[Global User Table (PostgreSQL)] --> B[Tenant Router]
    B --> C[Shared Cluster (MongoDB)]
    B --> D[Exclusive Cluster (PostgreSQL+Citus)]
    E[Application Layer] --> B
```

## 4. Setting Up MongoDB and PostgreSQL with Citus <a name="setup"></a>

### Prerequisites
- Servers: Multiple servers for database clusters.
- Operating System: Linux-based systems (e.g., Ubuntu).
- Access: Administrative privileges on all servers.

### Setting Up MongoDB Sharded Cluster

#### Step 1: Install MongoDB on All Servers
```bash
sudo apt-get update
sudo apt-get install -y mongodb
```

#### Step 2: Configure Config Servers
- Designate three servers as config servers.
- Modify mongod.conf to set replication and sharding options.

#### Step 3: Configure Shard Servers
- Set up shard servers with appropriate mongod.conf settings.
- Start mongod instances on all shard servers.

#### Step 4: Configure Query Routers
- Install and configure mongos on application servers.
- Connect mongos to the config servers.

#### Step 5: Initialize the Cluster
Use the mongo shell to add shards and enable sharding:
```javascript
sh.addShard("shard1.example.com:27017")
sh.addShard("shard2.example.com:27017")
sh.enableSharding("yourDatabase")
sh.shardCollection("yourDatabase.yourCollection", { "tenant_id": 1 })
```

### Setting Up PostgreSQL with Citus

#### Step 1: Install PostgreSQL
```bash
sudo apt-get update
sudo apt-get install -y postgresql postgresql-contrib
```

#### Step 2: Install Citus Extension
Add the Citus repository and install:

```bash
sudo apt-get install -y gnupg2 wget
wget -O- https://dist.citusdata.com/community/deb/PG_MAJOR/all/$(lsb_release -cs).asc | sudo apt-key add -
sudo apt-add-repository 'deb [arch=amd64] https://dist.citusdata.com/community/deb/PG_MAJOR/all/ $(lsb_release -cs) main'
sudo apt-get update
sudo apt-get install -y postgresql-12-citus-10.1
```

#### Step 3: Configure PostgreSQL
- Edit postgresql.conf to include shared_preload_libraries = 'citus'.
- Restart PostgreSQL:
```bash
sudo service postgresql restart
```

#### Step 4: Initialize Citus Nodes
- Coordinator Node: The main entry point for queries.
- Worker Nodes: Where data is actually stored.

On the coordinator node, add worker nodes:

```sql
SELECT master_add_node('worker1.example.com', 5432);
SELECT master_add_node('worker2.example.com', 5432);
```

#### Step 5: Distribute Tables
Create and distribute tables:

```sql
CREATE TABLE test_results (...);
SELECT create_distributed_table('test_results', 'tenant_id');
```

## 5. Developing Microservices on the Hybrid Architecture <a name="microservices"></a>

### Microservices Overview
- Tenant Management Service: Manages tenant configurations and database routing.
- User Management Service: Handles authentication and authorization.
- Test Execution Service: Orchestrates test runs and collects results.
- Data Migration Service: Handles tenant data migration between clusters.

### Best Practices

#### Use API Gateways
- Route requests to appropriate services.
- Implement authentication and rate limiting.

#### Implement Circuit Breakers
- Prevent cascading failures by handling service timeouts.

#### Logging and Monitoring
- Use centralized logging for troubleshooting.
- Monitor database performance and microservice health.

### Interaction with Databases

#### Database Abstraction Layer
- Implement a data access layer in each microservice.
- Use ODM/ORM tools:
  - MongoDB: Mongoose for Node.js, PyMongo for Python.
  - PostgreSQL: SQLAlchemy for Python, Sequelize for Node.js.

#### Tenant Routing Logic
- The Tenant Router determines the database based on tenant_id.
- Use middleware to inject routing logic into microservices.

### Sample Workflow

1. User Authentication:
   - User sends credentials to the User Management Service.
   - Service verifies credentials against the Global User Table.

2. Service Request:
   - User requests to run a test.
   - The request is routed to the Test Execution Service.

3. Data Storage:
   - Test results are stored in the appropriate database cluster.
   - Use tenant_id to determine storage location.

4. Data Retrieval:
   - When retrieving data, services query the correct database based on tenant_id.

### Handling Tenant Transitions

1. Trigger Migration: Tenant Management Service initiates migration.
2. Data Migration Service:
   - Extracts data from the source database.
   - Transforms and loads data into the target database.
3. Update Routing:
   - Tenant Router updates the tenant's database mapping.
4. Validation:
   - Verify data integrity post-migration.
5. Decommission:
   - Remove data from the old database after confirmation.

## Conclusion

Implementing a hybrid-sharded multi-tenant database architecture using MongoDB and PostgreSQL with Citus allows us to optimize performance, scalability, and resource utilization. By following this guide, you can set up the infrastructure and develop microservices that efficiently serve a diverse tenant base on a mobile testing platform.
